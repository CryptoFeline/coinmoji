<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Coinmoji Gl                <input type="range" id="bodyGlowIntensity" min="0.5" max="4.0" step="0.1" value="2.2">
                <span class="value-display" id="bodyGlowIntensityValue">2.2</span>
            </div>
            <div class="control">
                <label for="bodyGlowThreshold">Threshold:</label>
                <input type="range" id="bodyGlowThreshold" min="0.0" max="1.0" step="0.05" value="0.0" disabled>
                <span class="value-display" id="bodyGlowThresholdValue">0.0 (Fixed)</span>ct Test</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #1a1a1a;
            color: white;
            font-family: Arial, sans-serif;
            display: flex;
            gap: 20px;
        }
        
        #viewport {
            width: 400px;
            height: 400px;
            border: 2px solid #333;
            background: radial-gradient(circle, #222 0%, #111 100%);
        }
        
        .controls {
            flex: 1;
            min-width: 300px;
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            height: fit-content;
        }
        
        .control-group {
            margin-bottom: 20px;
            padding: 15px;
            background: #333;
            border-radius: 5px;
        }
        
        .control-group h3 {
            margin: 0 0 15px 0;
            color: #4CAF50;
        }
        
        .control {
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .control label {
            min-width: 120px;
            font-size: 14px;
        }
        
        .control input[type="range"] {
            flex: 1;
        }
        
        .control input[type="color"] {
            width: 50px;
            height: 30px;
            border: none;
            border-radius: 4px;
        }
        
        .control input[type="checkbox"] {
            width: 20px;
            height: 20px;
        }
        
        .control select {
            flex: 1;
            padding: 5px;
            background: #444;
            color: white;
            border: 1px solid #555;
            border-radius: 4px;
        }
        
        .value-display {
            min-width: 60px;
            text-align: right;
            font-family: monospace;
            color: #ccc;
        }
        
        .texture-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 10px;
        }
        
        .texture-btn {
            padding: 8px 12px;
            background: #555;
            border: none;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .texture-btn:hover {
            background: #666;
        }
        
        .texture-btn.active {
            background: #4CAF50;
        }
    </style>
</head>
<body>
    <div id="viewport"></div>
    
    <div class="controls">
        <h2>Glow Effect Test Controls</h2>
        
        <div class="control-group">
            <h3>üìç Coin Settings</h3>
            <div class="control">
                <label>Fill Mode:</label>
                <select id="fillMode">
                    <option value="solid">Solid Color</option>
                    <option value="gradient">Gradient</option>
                    <option value="texture">Texture</option>
                </select>
            </div>
            <div class="control">
                <label>Body Color:</label>
                <input type="color" id="bodyColor" value="#cecece">
            </div>
            <div class="control">
                <label>Gradient Start:</label>
                <input type="color" id="gradientStart" value="#00eaff">
            </div>
            <div class="control">
                <label>Gradient End:</label>
                <input type="color" id="gradientEnd" value="#ee00ff">
            </div>
            <div class="texture-buttons">
                <button class="texture-btn" data-texture="none">No Texture</button>
                <button class="texture-btn" data-texture="checker">Checker</button>
                <button class="texture-btn" data-texture="grid">Grid</button>
                <button class="texture-btn" data-texture="gradient">Radial Gradient</button>
            </div>
        </div>
        
        <div class="control-group">
            <h3>‚ú® Body Glow Settings</h3>
            <div class="control">
                <label>Enable Body Glow:</label>
                <input type="checkbox" id="bodyGlow" checked>
            </div>
            <div class="control">
                <label>Glow Scale:</label>
                <input type="range" id="bodyGlowScale" min="1.01" max="1.20" step="0.01" value="1.05">
                <span class="value-display" id="bodyGlowScaleValue">1.05</span>
            </div>
            <div class="control">
                <label>Glow Intensity:</label>
                <input type="range" id="bodyGlowIntensity" min="0.5" max="3.0" step="0.1" value="1.5">
                <span class="value-display" id="bodyGlowIntensityValue">1.5</span>
            </div>
            <div class="control">
                <label>Glow Threshold:</label>
                <input type="range" id="bodyGlowThreshold" min="0.0" max="1.0" step="0.05" value="0.60">
                <span class="value-display" id="bodyGlowThresholdValue">0.60</span>
            </div>
            <div class="control">
                <label>Glow Sharpness:</label>
                <input type="range" id="bodyGlowSharpness" min="0.1" max="2.0" step="0.1" value="0.6">
                <span class="value-display" id="bodyGlowSharpnessValue">0.6</span>
            </div>
            <div class="control">
                <label>Glow Scale:</label>
                <input type="range" id="bodyGlowScale" min="1.01" max="1.50" step="0.01" value="1.08">
                <span class="value-display" id="bodyGlowScaleValue">1.08</span>
            </div>
        </div>
        
        <div class="control-group">
            <h3>üé® Overlay Settings</h3>
            <div class="control">
                <label>Enable Overlay:</label>
                <input type="checkbox" id="hasOverlay">
            </div>
            <div class="texture-buttons">
                <button class="texture-btn" data-overlay="none">No Overlay</button>
                <button class="texture-btn" data-overlay="logo">Logo</button>
                <button class="texture-btn" data-overlay="pattern">Pattern</button>
                <button class="texture-btn" data-overlay="emoji">Emoji</button>
            </div>
        </div>
        
        <div class="control-group">
            <h3>‚ú® Overlay Glow Settings</h3>
            <div class="control">
                <label>Enable Overlay Glow:</label>
                <input type="checkbox" id="overlayGlow">
            </div>
            <div class="control">
                <label>Glow Scale:</label>
                <input type="range" id="overlayGlowScale" min="1.01" max="1.15" step="0.005" value="1.03">
                <span class="value-display" id="overlayGlowScaleValue">1.03</span>
            </div>
            <div class="control">
                <label>Glow Intensity:</label>
                <input type="range" id="overlayGlowIntensity" min="0.5" max="4.0" step="0.1" value="2.0">
                <span class="value-display" id="overlayGlowIntensityValue">2.0</span>
            </div>
            <div class="control">
                <label>Glow Threshold:</label>
                <input type="range" id="overlayGlowThreshold" min="0.0" max="1.0" step="0.05" value="0.70">
                <span class="value-display" id="overlayGlowThresholdValue">0.70</span>
            </div>
            <div class="control">
                <label>Glow Sharpness:</label>
                <input type="range" id="overlayGlowSharpness" min="0.1" max="2.0" step="0.1" value="1.0">
                <span class="value-display" id="overlayGlowSharpnessValue">1.0</span>
            </div>
        </div>
        
        <div class="control-group">
            <h3>üîß Render Settings</h3>
            <div class="control">
                <label>Depth Test:</label>
                <input type="checkbox" id="depthTest" checked>
            </div>
            <div class="control">
                <label>Background:</label>
                <select id="background">
                    <option value="dark">Dark</option>
                    <option value="light">Light</option>
                    <option value="transparent">Transparent</option>
                </select>
            </div>
            <div class="control">
                <label>Rotation Speed:</label>
                <input type="range" id="rotationSpeed" min="0" max="2" step="0.1" value="0.5">
                <span class="value-display" id="rotationSpeedValue">0.5</span>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
    <script>
        // Global variables
        let scene, camera, renderer, coinGroup, glowMeshes = {};
        let bodyMaterial, overlayMaterial;
        let currentTexture = null, currentOverlay = null;
        
        // Initialize the scene
        function init() {
            // Scene setup
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
            camera.position.set(0, 0, 2.8);
            camera.lookAt(0, 0, 0);
            
            // Renderer setup
            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true,
                premultipliedAlpha: false
            });
            renderer.setSize(400, 400);
            renderer.setClearColor(0x111111, 1);
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            renderer.toneMapping = THREE.LinearToneMapping;
            renderer.toneMappingExposure = 0.8;
            
            document.getElementById('viewport').appendChild(renderer.domElement);
            
            // Lighting
            setupLighting();
            
            // Create coin
            createCoin();
            
            // Setup glow materials
            setupGlowMaterials();
            
            // Create glow meshes
            createGlowMeshes();
            
            // Setup controls
            setupControls();
            
            // Start animation loop
            animate();
            
            console.log('‚úÖ Glow test initialized');
        }
        
        function setupLighting() {
            const hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.45);
            scene.add(hemiLight);
            
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(3, 5, 2);
            scene.add(dirLight);
            
            const fillLight = new THREE.DirectionalLight(0xffffff, 0.6);
            fillLight.position.set(-2, -3, -1);
            scene.add(fillLight);
            
            const rimLight = new THREE.DirectionalLight(0xffffff, 0.4);
            rimLight.position.set(-3, 1, 4);
            scene.add(rimLight);
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
        }
        
        function createCoin() {
            // Coin parameters
            const R = 1.0;
            const T = 0.35;
            const bulge = 0.15;
            const radialSegments = 128;
            const capSegments = 32;
            
            // Materials
            bodyMaterial = new THREE.MeshStandardMaterial({
                color: 0xcecece,
                metalness: 0.8,
                roughness: 0.34,
                envMapIntensity: 1
            });
            
            overlayMaterial = new THREE.MeshStandardMaterial({
                transparent: true,
                metalness: 0.6,
                roughness: 0.3,
                polygonOffset: true,
                polygonOffsetFactor: -1,
                polygonOffsetUnits: -1,
                opacity: 0
            });
            
            // Geometry
            const cylinderGeometry = new THREE.CylinderGeometry(R, R, T, radialSegments, 1, true);
            const cylinder = new THREE.Mesh(cylinderGeometry, bodyMaterial);
            
            // Face creation function
            const createFace = (isTop) => {
                const geometry = new THREE.SphereGeometry(
                    R, radialSegments, capSegments, 0, Math.PI * 2,
                    isTop ? 0 : Math.PI / 2, Math.PI / 2
                );
                geometry.scale(1, bulge / R, 1);
                geometry.translate(0, isTop ? T / 2 : -T / 2, 0);
                return new THREE.Mesh(geometry, bodyMaterial);
            };
            
            const topFace = createFace(true);
            const bottomFace = createFace(false);
            
            // Overlay meshes
            const createOverlay = (isTop) => {
                const mesh = createFace(isTop);
                mesh.material = overlayMaterial.clone();
                
                // Apply planar UV mapping for overlays
                const geometry = mesh.geometry;
                geometry.computeBoundingBox();
                const bb = geometry.boundingBox;
                const r = Math.max(
                    Math.abs(bb.max.x), Math.abs(bb.min.x),
                    Math.abs(bb.max.z), Math.abs(bb.min.z)
                );
                
                const position = geometry.attributes.position;
                const uvArray = new Float32Array(position.count * 2);
                
                for (let i = 0; i < position.count; i++) {
                    const x = position.getX(i);
                    const z = position.getZ(i);
                    const u = 0.5 + (x / r) * 0.48;
                    const v = 1 - (0.5 + (z / r) * 0.48);
                    uvArray[i * 2] = u;
                    uvArray[i * 2 + 1] = v;
                }
                
                geometry.setAttribute('uv', new THREE.BufferAttribute(uvArray, 2));
                return mesh;
            };
            
            const overlayTop = createOverlay(true);
            const overlayBot = createOverlay(false);
            
            // Store references
            window.coinMeshes = {
                cylinder, topFace, bottomFace, 
                overlayTop, overlayBot
            };
            
            // Assembly
            coinGroup = new THREE.Group();
            coinGroup.add(cylinder, topFace, bottomFace, overlayTop, overlayBot);
            coinGroup.rotation.x = Math.PI / 2; // Stand on edge
            
            const turntable = new THREE.Group();
            turntable.add(coinGroup);
            scene.add(turntable);
            
            window.turntable = turntable; // For rotation
        }
        
        function setupGlowMaterials() {
            // Define GlowMapMaterial class
            window.GlowMapMaterial = class extends THREE.ShaderMaterial {
                constructor(params) {
                    const p = params || {};
                    super({
                        uniforms: {
                            glowColor: { value: new THREE.Color(p.color || 0xffffff) },
                            map: { value: p.map || null },
                            useMap: { value: !!p.map },
                            intensity: { value: p.intensity !== undefined ? p.intensity : 1.0 },
                            threshold: { value: p.threshold !== undefined ? p.threshold : 0.70 },
                            sharpness: { value: p.sharpness !== undefined ? p.sharpness : 0.5 },
                        },
                        transparent: true,
                        depthTest: true,
                        depthWrite: false,
                        blending: THREE.AdditiveBlending,
                        side: THREE.FrontSide,  // FIXED: Use FrontSide for proper outward glow
                        alphaTest: 0.01,
                        vertexShader: `
                            varying vec3 vWorldPos;
                            varying vec3 vWorldNormal;
                            varying vec2 vUv;
                            void main() {
                                vUv = uv;
                                vec4 wp = modelMatrix * vec4(position, 1.0);
                                vWorldPos = wp.xyz;
                                vWorldNormal = normalize(mat3(modelMatrix) * normal);
                                gl_Position = projectionMatrix * viewMatrix * wp;
                            }
                        `,
                        fragmentShader: `
                            uniform vec3 glowColor;
                            uniform sampler2D map;
                            uniform bool useMap;
                            uniform float intensity;
                            uniform float threshold;
                            uniform float sharpness;
                            varying vec3 vWorldPos;
                            varying vec3 vWorldNormal;
                            varying vec2 vUv;

                            // Improved edge detection function
                            float getEdgeStrength(vec2 uv) {
                                if (!useMap) return 1.0;
                                
                                vec2 texelSize = 1.0 / vec2(textureSize(map, 0));
                                vec3 center = texture2D(map, uv).rgb;
                                
                                // Sample neighboring pixels for edge detection
                                vec3 right = texture2D(map, uv + vec2(texelSize.x, 0.0)).rgb;
                                vec3 left = texture2D(map, uv - vec2(texelSize.x, 0.0)).rgb;
                                vec3 up = texture2D(map, uv + vec2(0.0, texelSize.y)).rgb;
                                vec3 down = texture2D(map, uv - vec2(0.0, texelSize.y)).rgb;
                                
                                // Calculate gradient magnitude
                                vec3 gradX = right - left;
                                vec3 gradY = up - down;
                                float grad = length(gradX) + length(gradY);
                                
                                return smoothstep(0.1, 0.5, grad);
                            }

                            void main() {
                                // Get base color from texture or uniform
                                vec3 base = useMap ? texture2D(map, vUv).rgb : glowColor;
                                
                                // Enhanced brightness gate with perceptual weighting
                                float luma = dot(base, vec3(0.299, 0.587, 0.114)); // More accurate perceptual weights
                                float brightGate = smoothstep(threshold * 0.8, threshold + 0.2, luma);
                                
                                // Edge detection for texture detail enhancement
                                float edgeStrength = getEdgeStrength(vUv);
                                
                                // Fixed fresnel calculation for FrontSide outward glow
                                vec3 V = normalize(cameraPosition - vWorldPos);
                                vec3 N = normalize(vWorldNormal);
                                
                                // Primary fresnel for main glow (fixed for FrontSide)
                                float NdotV = dot(N, V);
                                float fresnel1 = 1.0 - max(0.0, NdotV);
                                float rim1 = pow(fresnel1, 0.3 + sharpness * 1.5);
                                
                                // Secondary fresnel for edge enhancement
                                float fresnel2 = 1.0 - pow(max(0.0, NdotV), 0.5);
                                float rim2 = pow(fresnel2, 1.0 + sharpness * 2.0);
                                
                                // Combine multiple glow components
                                float primaryGlow = rim1 * brightGate;
                                float edgeGlow = rim2 * edgeStrength * 0.6;
                                float combinedGlow = primaryGlow + edgeGlow;
                                
                                // Apply intensity with improved falloff
                                float glowStrength = combinedGlow * intensity;
                                float alpha = smoothstep(0.0, 1.2, glowStrength);
                                
                                // Enhanced color mixing with saturation boost for bright areas
                                vec3 finalColor = base * (1.0 + alpha * 0.5);
                                if (brightGate > 0.5) {
                                    // Boost saturation for bright glowing areas
                                    float satBoost = (brightGate - 0.5) * 0.4;
                                    vec3 gray = vec3(luma);
                                    finalColor = mix(finalColor, finalColor + (finalColor - gray) * satBoost, satBoost);
                                }
                                
                                gl_FragColor = vec4(finalColor, alpha * 0.9);

                                #include <tonemapping_fragment>
                                #include <colorspace_fragment>
                            }
                        `
                    });
                }
                
                updateGlowSource(map, color) {
                    this.uniforms.map.value = map;
                    this.uniforms.useMap.value = !!map;
                    this.uniforms.glowColor.value.copy(color);
                    this.needsUpdate = true;
                }
            };
        }
        
        function createGlowMeshes() {
            const meshes = window.coinMeshes;
            
            // Body glow meshes
            glowMeshes.cylinder = new THREE.Mesh(
                meshes.cylinder.geometry,
                new window.GlowMapMaterial({
                    color: bodyMaterial.color,
                    threshold: 0.0,      // Fixed: Always 0, not user-adjustable
                    intensity: 2.2,     // Updated default
                    sharpness: 0.6,     // Updated default
                })
            );
            glowMeshes.cylinder.scale.setScalar(1.08);  // Updated scale
            glowMeshes.cylinder.renderOrder = 1;
            
            glowMeshes.topFace = new THREE.Mesh(
                meshes.topFace.geometry.clone(),
                new window.GlowMapMaterial({
                    color: bodyMaterial.color,
                    threshold: 0.0,     // Fixed: Always 0, not user-adjustable
                    intensity: 2.2,     // Updated default
                    sharpness: 0.6,     // Updated default
                })
            );
            glowMeshes.topFace.scale.setScalar(1.08);   // Updated scale
            glowMeshes.topFace.renderOrder = 1;
            
            glowMeshes.bottomFace = new THREE.Mesh(
                meshes.bottomFace.geometry.clone(),
                new window.GlowMapMaterial({
                    color: bodyMaterial.color,
                    threshold: 0.0,     // Fixed: Always 0, not user-adjustable
                    intensity: 2.2,     // Updated default
                    sharpness: 0.6,     // Updated default
                })
            );
            glowMeshes.bottomFace.scale.setScalar(1.08); // Updated scale
            glowMeshes.bottomFace.renderOrder = 1;
            
            // Overlay glow meshes
            glowMeshes.overlayTop = new THREE.Mesh(
                meshes.overlayTop.geometry,
                new window.GlowMapMaterial({
                    threshold: 0.70,
                    intensity: 2.0,
                    sharpness: 1.0
                })
            );
            glowMeshes.overlayTop.scale.setScalar(1.03);
            glowMeshes.overlayTop.renderOrder = 2;
            glowMeshes.overlayTop.visible = false;
            
            glowMeshes.overlayBot = new THREE.Mesh(
                meshes.overlayBot.geometry,
                new window.GlowMapMaterial({
                    threshold: 0.70,
                    intensity: 2.0,
                    sharpness: 1.0
                })
            );
            glowMeshes.overlayBot.scale.setScalar(1.03);
            glowMeshes.overlayBot.renderOrder = 2;
            glowMeshes.overlayBot.visible = false;
            
            // Add to coin group
            coinGroup.add(
                glowMeshes.cylinder,
                glowMeshes.topFace,
                glowMeshes.bottomFace,
                glowMeshes.overlayTop,
                glowMeshes.overlayBot
            );
        }
        
        function setupControls() {
            // Body glow controls
            document.getElementById('bodyGlow').addEventListener('change', updateBodyGlow);
            document.getElementById('bodyGlowScale').addEventListener('input', updateBodyGlowScale);
            document.getElementById('bodyGlowIntensity').addEventListener('input', updateBodyGlowIntensity);
            document.getElementById('bodyGlowThreshold').addEventListener('input', updateBodyGlowThreshold);
            document.getElementById('bodyGlowSharpness').addEventListener('input', updateBodyGlowSharpness);
            
            // Overlay glow controls
            document.getElementById('overlayGlow').addEventListener('change', updateOverlayGlow);
            document.getElementById('overlayGlowScale').addEventListener('input', updateOverlayGlowScale);
            document.getElementById('overlayGlowIntensity').addEventListener('input', updateOverlayGlowIntensity);
            document.getElementById('overlayGlowThreshold').addEventListener('input', updateOverlayGlowThreshold);
            document.getElementById('overlayGlowSharpness').addEventListener('input', updateOverlayGlowSharpness);
            
            // Material controls
            document.getElementById('fillMode').addEventListener('change', updateMaterial);
            document.getElementById('bodyColor').addEventListener('change', updateMaterial);
            document.getElementById('gradientStart').addEventListener('change', updateMaterial);
            document.getElementById('gradientEnd').addEventListener('change', updateMaterial);
            
            // Render controls
            document.getElementById('depthTest').addEventListener('change', updateDepthTest);
            document.getElementById('background').addEventListener('change', updateBackground);
            document.getElementById('rotationSpeed').addEventListener('input', updateRotationSpeed);
            
            // Texture buttons
            document.querySelectorAll('.texture-btn[data-texture]').forEach(btn => {
                btn.addEventListener('click', () => setTexture(btn.dataset.texture));
            });
            
            document.querySelectorAll('.texture-btn[data-overlay]').forEach(btn => {
                btn.addEventListener('click', () => setOverlay(btn.dataset.overlay));
            });
            
            // Value display updates
            setupValueDisplays();
        }
        
        function setupValueDisplays() {
            const sliders = ['bodyGlowScale', 'bodyGlowIntensity', 'bodyGlowThreshold', 'bodyGlowSharpness',
                            'overlayGlowScale', 'overlayGlowIntensity', 'overlayGlowThreshold', 'overlayGlowSharpness',
                            'rotationSpeed'];
            
            sliders.forEach(id => {
                const slider = document.getElementById(id);
                const display = document.getElementById(id + 'Value');
                slider.addEventListener('input', () => {
                    display.textContent = slider.value;
                });
            });
        }
        
        function updateBodyGlow() {
            const enabled = document.getElementById('bodyGlow').checked;
            glowMeshes.cylinder.visible = enabled;
            glowMeshes.topFace.visible = enabled;
            glowMeshes.bottomFace.visible = enabled;
        }
        
        function updateBodyGlowScale() {
            const scale = parseFloat(document.getElementById('bodyGlowScale').value);
            glowMeshes.cylinder.scale.setScalar(scale);
            glowMeshes.topFace.scale.setScalar(scale);
            glowMeshes.bottomFace.scale.setScalar(scale);
        }
        
        function updateBodyGlowIntensity() {
            const intensity = parseFloat(document.getElementById('bodyGlowIntensity').value);
            glowMeshes.cylinder.material.uniforms.intensity.value = intensity;
            glowMeshes.topFace.material.uniforms.intensity.value = intensity;
            glowMeshes.bottomFace.material.uniforms.intensity.value = intensity;
        }
        
        function updateBodyGlowThreshold() {
            const threshold = parseFloat(document.getElementById('bodyGlowThreshold').value);
            glowMeshes.cylinder.material.uniforms.threshold.value = threshold;
            glowMeshes.topFace.material.uniforms.threshold.value = threshold;
            glowMeshes.bottomFace.material.uniforms.threshold.value = threshold;
        }
        
        function updateBodyGlowSharpness() {
            const sharpness = parseFloat(document.getElementById('bodyGlowSharpness').value);
            glowMeshes.cylinder.material.uniforms.sharpness.value = sharpness;
            glowMeshes.topFace.material.uniforms.sharpness.value = sharpness;
            glowMeshes.bottomFace.material.uniforms.sharpness.value = sharpness;
        }
        
        function updateOverlayGlow() {
            const enabled = document.getElementById('overlayGlow').checked;
            const hasOverlay = document.getElementById('hasOverlay').checked;
            glowMeshes.overlayTop.visible = enabled && hasOverlay;
            glowMeshes.overlayBot.visible = enabled && hasOverlay;
        }
        
        function updateOverlayGlowScale() {
            const scale = parseFloat(document.getElementById('overlayGlowScale').value);
            glowMeshes.overlayTop.scale.setScalar(scale);
            glowMeshes.overlayBot.scale.setScalar(scale);
        }
        
        function updateOverlayGlowIntensity() {
            const intensity = parseFloat(document.getElementById('overlayGlowIntensity').value);
            glowMeshes.overlayTop.material.uniforms.intensity.value = intensity;
            glowMeshes.overlayBot.material.uniforms.intensity.value = intensity;
        }
        
        function updateOverlayGlowThreshold() {
            const threshold = parseFloat(document.getElementById('overlayGlowThreshold').value);
            glowMeshes.overlayTop.material.uniforms.threshold.value = threshold;
            glowMeshes.overlayBot.material.uniforms.threshold.value = threshold;
        }
        
        function updateOverlayGlowSharpness() {
            const sharpness = parseFloat(document.getElementById('overlayGlowSharpness').value);
            glowMeshes.overlayTop.material.uniforms.sharpness.value = sharpness;
            glowMeshes.overlayBot.material.uniforms.sharpness.value = sharpness;
        }
        
        function updateMaterial() {
            const fillMode = document.getElementById('fillMode').value;
            const bodyColor = document.getElementById('bodyColor').value;
            const gradientStart = document.getElementById('gradientStart').value;
            const gradientEnd = document.getElementById('gradientEnd').value;
            
            if (fillMode === 'solid') {
                bodyMaterial.map = null;
                bodyMaterial.color.setHex(bodyColor.replace('#', '0x'));
                
                // Update body glow
                glowMeshes.cylinder.material.updateGlowSource(null, bodyMaterial.color);
                glowMeshes.topFace.material.updateGlowSource(null, bodyMaterial.color);
                glowMeshes.bottomFace.material.updateGlowSource(null, bodyMaterial.color);
                
            } else if (fillMode === 'gradient') {
                // Create gradient texture
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 256;
                
                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, gradientStart);
                gradient.addColorStop(1, gradientEnd);
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const texture = new THREE.CanvasTexture(canvas);
                texture.colorSpace = THREE.SRGBColorSpace;
                
                bodyMaterial.map = texture;
                bodyMaterial.color.setHex(0xffffff);
                
                // Update body glow
                glowMeshes.cylinder.material.updateGlowSource(texture, new THREE.Color(0xffffff));
                glowMeshes.topFace.material.updateGlowSource(texture, new THREE.Color(0xffffff));
                glowMeshes.bottomFace.material.updateGlowSource(texture, new THREE.Color(0xffffff));
            }
            
            bodyMaterial.needsUpdate = true;
        }
        
        function setTexture(textureType) {
            // Update button states
            document.querySelectorAll('.texture-btn[data-texture]').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.texture === textureType);
            });
            
            if (textureType === 'none') {
                document.getElementById('fillMode').value = 'solid';
                updateMaterial();
                return;
            }
            
            // Create test textures
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 256;
            
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, 256, 256);
            
            if (textureType === 'checker') {
                ctx.fillStyle = '#000000';
                for (let x = 0; x < 256; x += 32) {
                    for (let y = 0; y < 256; y += 32) {
                        if ((Math.floor(x/32) + Math.floor(y/32)) % 2 === 0) {
                            ctx.fillRect(x, y, 32, 32);
                        }
                    }
                }
            } else if (textureType === 'grid') {
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;
                for (let i = 0; i < 256; i += 32) {
                    ctx.beginPath();
                    ctx.moveTo(i, 0);
                    ctx.lineTo(i, 256);
                    ctx.moveTo(0, i);
                    ctx.lineTo(256, i);
                    ctx.stroke();
                }
            } else if (textureType === 'gradient') {
                const radialGrad = ctx.createRadialGradient(128, 128, 0, 128, 128, 128);
                radialGrad.addColorStop(0, '#ffffff');
                radialGrad.addColorStop(1, '#000000');
                ctx.fillStyle = radialGrad;
                ctx.fillRect(0, 0, 256, 256);
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.colorSpace = THREE.SRGBColorSpace;
            
            bodyMaterial.map = texture;
            bodyMaterial.color.setHex(0xffffff);
            bodyMaterial.needsUpdate = true;
            
            document.getElementById('fillMode').value = 'texture';
            
            // Update body glow
            glowMeshes.cylinder.material.updateGlowSource(texture, new THREE.Color(0xffffff));
            glowMeshes.topFace.material.updateGlowSource(texture, new THREE.Color(0xffffff));
            glowMeshes.bottomFace.material.updateGlowSource(texture, new THREE.Color(0xffffff));
        }
        
        function setOverlay(overlayType) {
            // Update button states
            document.querySelectorAll('.texture-btn[data-overlay]').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.overlay === overlayType);
            });
            
            const hasOverlay = overlayType !== 'none';
            document.getElementById('hasOverlay').checked = hasOverlay;
            
            const meshes = window.coinMeshes;
            
            if (!hasOverlay) {
                meshes.overlayTop.material.opacity = 0;
                meshes.overlayBot.material.opacity = 0;
                updateOverlayGlow();
                return;
            }
            
            // Create overlay textures
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 256;
            
            ctx.fillStyle = 'rgba(0,0,0,0)';
            ctx.fillRect(0, 0, 256, 256);
            
            if (overlayType === 'logo') {
                ctx.fillStyle = '#4CAF50';
                ctx.fillRect(60, 60, 136, 136);
                ctx.fillStyle = '#ffffff';
                ctx.font = '48px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('C', 128, 148);
            } else if (overlayType === 'pattern') {
                ctx.fillStyle = '#FF5722';
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const x = 128 + Math.cos(angle) * 60;
                    const y = 128 + Math.sin(angle) * 60;
                    ctx.beginPath();
                    ctx.arc(x, y, 20, 0, Math.PI * 2);
                    ctx.fill();
                }
            } else if (overlayType === 'emoji') {
                ctx.font = '100px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('üöÄ', 128, 148);
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.colorSpace = THREE.SRGBColorSpace;
            texture.flipY = true;
            
            meshes.overlayTop.material.map = texture;
            meshes.overlayTop.material.opacity = 1;
            meshes.overlayTop.material.needsUpdate = true;
            
            // Create bottom texture (flipped)
            const bottomTexture = texture.clone();
            bottomTexture.wrapS = THREE.RepeatWrapping;
            bottomTexture.repeat.x = -1;
            
            meshes.overlayBot.material.map = bottomTexture;
            meshes.overlayBot.material.opacity = 1;
            meshes.overlayBot.material.needsUpdate = true;
            
            // Update overlay glow
            glowMeshes.overlayTop.material.updateGlowSource(texture, new THREE.Color(0xffffff));
            glowMeshes.overlayBot.material.updateGlowSource(bottomTexture, new THREE.Color(0xffffff));
            
            updateOverlayGlow();
        }
        
        function updateDepthTest() {
            const enabled = document.getElementById('depthTest').checked;
            Object.values(glowMeshes).forEach(mesh => {
                mesh.material.depthTest = enabled;
            });
        }
        
        function updateBackground() {
            const bg = document.getElementById('background').value;
            if (bg === 'dark') {
                renderer.setClearColor(0x111111, 1);
            } else if (bg === 'light') {
                renderer.setClearColor(0xffffff, 1);
            } else {
                renderer.setClearColor(0x000000, 0);
            }
        }
        
        function updateRotationSpeed() {
            // This will be used in animate() function
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Rotate coin
            const rotationSpeed = parseFloat(document.getElementById('rotationSpeed').value);
            if (window.turntable) {
                window.turntable.rotation.y += 0.01 * rotationSpeed;
            }
            
            renderer.render(scene, camera);
        }
        
        // Initialize when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
